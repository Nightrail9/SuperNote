[
  {
    "id": "note_b0619158d155",
    "title": "【Docker】将微服务镜像发布到私有镜像仓库",
    "sourceUrl": "https://www.bilibili.com/video/BV1QV1xBBE6y?spm_id_from=333.788.videopod.episodes&vd_source=2a985ca1c3a6930df4b372bbf6082ce6&p=6",
    "contentMd": "# 【Docker】将微服务镜像发布到私有镜像仓库\n\n## 目录\n- [1. 背景与目标](#1-背景与目标)\n- [2. 使用 Docker Compose 搭建私有 Registry](#2-使用-docker-compose-搭建私有-registry)\n  - [2.1 创建数据目录](#21-创建数据目录)\n  - [2.2 编写 docker-compose.yml](#22-编写-docker-composeyml)\n  - [2.3 启动私有仓库](#23-启动私有仓库)\n- [3. 配置私有仓库认证](#3-配置私有仓库认证)\n  - [3.1 生成密码文件](#31-生成密码文件)\n  - [3.2 登录验证](#32-登录验证)\n  - [3.3 解决 HTTPS 错误](#33-解决-https-错误)\n- [4. 推送镜像到私有仓库](#4-推送镜像到私有仓库)\n  - [4.1 方式一：构建时指定仓库地址](#41-方式一构建时指定仓库地址)\n  - [4.2 方式二：给现有镜像打标签后推送](#42-方式二给现有镜像打标签后推送)\n- [5. 从私有仓库拉取镜像](#5-从私有仓库拉取镜像)\n- [6. AI 总结](#6-ai-总结)\n\n---\n\n## 1. 背景与目标\n\n之前讲解了将微服务镜像发布到**阿里云远程镜像仓库**，但阿里云企业版是**收费**的。对于公司内部使用，更好的方案是**自建私有镜像仓库**，将电商项目的各个微服务模块都上传到私有仓库中。\n\n本视频演示如何利用 **Docker** 搭建私有镜像仓库，并使用 **Docker Compose** 进行容器编排管理。\n\n> **Docker Compose 优势**：相比直接使用 `docker run`，Compose 可以通过一个脚本文件（YAML）批量启动多个容器，并自动处理服务间的**依赖关系**（如授权中心必须先启动，再启动网关服务）。\n\n---\n\n## 2. 使用 Docker Compose 搭建私有 Registry\n\n### 2.1 创建数据目录\n\n首先指定私有仓库的数据存储目录（示例：`/data/docker-registry`），确保数据持久化保存在宿主机上。\n\n```bash\nmkdir -p /data/docker-registry\n```\n\n### 2.2 编写 docker-compose.yml\n\n创建 `docker-compose.yml` 文件，定义 Registry 服务：\n\n```yaml\nversion: '3'\nservices:\n  registry:\n    container_name: docker-registry      # 容器名称\n    image: registry:2                   # 使用 registry:2 镜像\n    ports:\n      - \"5000:5000\"                     # 映射端口：宿主机5000 → 容器5000\n    volumes:\n      - /data/docker-registry:/var/lib/registry  # 数据持久化挂载\n```\n\n**关键配置说明**：\n| 配置项 | 说明 |\n|--------|------|\n| `image: registry:2` | Docker 官方提供的 Registry 镜像 |\n| `ports: 5000:5000` | Registry 默认暴露端口为 5000 |\n| `volumes` | 将容器内 `/var/lib/registry` 挂载到宿主机，实现数据持久化 |\n\n### 2.3 启动私有仓库\n\n执行命令启动服务：\n\n```bash\ndocker-compose up -d\n```\n\n> **注意**：默认读取 `docker-compose.yml` 文件。若文件名不同（如 `tuling-compose.yml`），需指定 `-f tuling-compose.yml`。\n\n验证容器状态：\n```bash\ndocker ps\n```\n\n---\n\n## 3. 配置私有仓库认证\n\n### 3.1 生成密码文件\n\n私有仓库需要设置用户密码，防止未授权访问：\n\n```bash\n# 生成 htpasswd 密码文件（用户：fox，密码：123456）\nhtpasswd -Bbn fox 123456 > auth/htpasswd\n```\n\n### 3.2 登录验证\n\n尝试登录私有仓库：\n```bash\ndocker login 192.168.65.184:5000\n```\n\n输入用户名 `fox` 和密码 `123456`。\n\n### 3.3 解决 HTTPS 错误\n\n**问题现象**：登录时报错 `server gave HTTP response to HTTPS client`\n\n**原因**：Docker 默认要求使用 HTTPS，但私有仓库未配置 SSL 证书。\n\n**解决方案**：配置 Docker 信任该私有仓库地址。\n\n编辑 Docker 配置文件：\n```bash\nvim /etc/docker/daemon.json\n```\n\n添加 `insecure-registries` 配置：\n```json\n{\n  \"insecure-registries\": [\"192.168.65.184:5000\"]\n}\n```\n\n**重启 Docker 服务**：\n```bash\nsystemctl restart docker\n```\n\n> 重启 Docker 后，之前运行的 Registry 容器也会停止，需要重新启动：\n> ```bash\n> docker start docker-registry\n> ```\n\n---\n\n## 4. 推送镜像到私有仓库\n\n### 4.1 方式一：构建时指定仓库地址\n\n在构建镜像时直接指定完整的仓库路径：\n\n```bash\ncd /path/to/project\n\ndocker build -t 192.168.65.184:5000/tuling-mall-gateway:0.0.5 .\n```\n\n参数说明：\n- `192.168.65.184:5000` — 私有仓库地址\n- `tuling-mall-gateway` — 镜像名称（命名空间/项目名）\n- `0.0.5` — 版本标签\n\n构建完成后直接推送：\n```bash\ndocker push 192.168.65.184:5000/tuling-mall-gateway:0.0.5\n```\n\n### 4.2 方式二：给现有镜像打标签后推送\n\n若已有本地镜像，可通过 `tag` 命令重新标记：\n\n```bash\n# 给现有镜像打新标签\ndocker tag 原镜像名 192.168.65.184:5000/镜像名:版本\n\n# 然后推送\ndocker push 192.168.65.184:5000/镜像名:版本\n```\n\n**验证推送结果**：\n```bash\n# 查看本地镜像\ndocker images\n\n# 浏览器访问或 curl 查看仓库内容\ncurl http://192.168.65.184:5000/v2/_catalog\n```\n\n返回示例：\n```json\n{\"repositories\":[\"tuling-mall-gateway\"]}\n```\n\n---\n\n## 5. 从私有仓库拉取镜像\n\n```bash\n# 拉取指定版本镜像\ndocker pull 192.168.65.184:5000/tuling-mall-gateway:0.0.5\n\n# 运行容器\ndocker run -d --name gateway 192.168.65.184:5000/tuling-mall-gateway:0.0.5\n```\n\n> **注意**：拉取时必须指定版本号，否则默认找 `latest` 可能报错。\n\n---\n\n## 6. AI 总结\n\n本视频系统讲解了基于 **Docker Registry** 搭建私有镜像仓库的完整流程，核心要点包括：\n\n1. **技术选型**：使用 Docker 官方 `registry:2` 镜像快速部署，通过 Docker Compose 实现容器编排，避免手动管理多个容器的繁琐操作。\n\n2. **关键配置**：数据持久化通过 `volumes` 挂载到宿主机；安全认证采用 `htpasswd` 生成密码文件；网络层面需配置 `insecure-registries` 解决 HTTP/HTTPS 协议冲突。\n\n3. **镜像生命周期管理**：演示了两种推送模式——构建时直接指定仓库地址（推荐），或对已有镜像重新打标签后推送。同时强调了版本号规范的重要性。\n\n4. **生产建议**：私有仓库适合企业内部 CI/CD 流水线集成，后续可结合 Harbor 等更完善的企业级镜像仓库方案，实现镜像扫描、权限管理等高级功能。\n\n整体而言，该方案是微服务架构中镜像分发的轻量级基础设施，为后续的 Kubernetes 集群部署奠定基础。",
    "createdAt": "2026-02-20T04:15:13.865Z",
    "updatedAt": "2026-02-20T04:15:13.865Z"
  },
  {
    "id": "note_e2bee9db6352",
    "title": "【Docker】将微服务镜像发布到阿里云远程镜像仓库",
    "sourceUrl": "https://www.bilibili.com/video/BV1QV1xBBE6y?spm_id_from=333.788.videopod.episodes&vd_source=2a985ca1c3a6930df4b372bbf6082ce6&p=5",
    "contentMd": "# 【Docker】将微服务镜像发布到阿里云远程镜像仓库\n\n## 目录\n- [1. 背景与问题](#1-背景与问题)\n- [2. 解决方案：阿里云容器镜像服务](#2-解决方案阿里云容器镜像服务)\n- [3. 操作步骤详解](#3-操作步骤详解)\n  - [3.1 创建命名空间](#31-创建命名空间)\n  - [3.2 登录阿里云镜像仓库](#32-登录阿里云镜像仓库)\n  - [3.3 给本地镜像打标签](#33-给本地镜像打标签)\n  - [3.4 推送镜像到远程仓库](#34-推送镜像到远程仓库)\n  - [3.5 验证与拉取测试](#35-验证与拉取测试)\n- [4. AI 总结](#4-ai-总结)\n\n---\n\n## 1. 背景与问题\n\n在掌握了如何将微服务构建成 Docker 镜像后，面临一个新的挑战：**如何在多台服务器之间共享镜像**。\n\n- 当前环境：已在 `1847` 机器上通过 `docker ps` 运行了微服务容器，且可以正常访问（端口 `18488`）\n- 核心问题：另一台 `1747` 机器需要部署相同服务，但其本地镜像仓库中不存在该镜像\n- 解决思路：需要构建一个**远程镜像仓库**，使多台机器能够共享和获取镜像\n\n**可选方案对比：**\n| 方案 | 说明 | 适用场景 |\n|:---|:---|:---|\n| Docker Hub 官方仓库 | 国外服务，访问受限 | 一般不考虑 |\n| 自建私有仓库 | 自行搭建 Registry | 企业内部、高可控需求 |\n| **阿里云容器镜像服务** | 国内云服务，稳定快速 | **推荐，适合学习和生产** |\n\n> 注：之前配置 Docker 环境时使用的\"阿里云镜像加速器\"，实际上就是阿里云提供的容器镜像服务的一部分。\n\n---\n\n## 2. 解决方案：阿里云容器镜像服务\n\n阿里云容器镜像服务（Container Registry）提供个人版实例，适合学习和小型项目使用。\n\n**核心概念：**\n- **命名空间（Namespace）**：镜像的逻辑分组，用于组织管理多个镜像仓库\n- **镜像仓库（Repository）**：存放具体镜像的地方，包含不同版本（Tag）\n\n---\n\n## 3. 操作步骤详解\n\n### 3.1 创建命名空间\n\n1\\. 登录阿里云控制台，进入**容器镜像服务**\n2\\. 选择**个人实例**（免费额度足够学习使用）\n3\\. 进入**命名空间**管理页面，点击\"创建命名空间\"\n4\\. 填写命名空间名称，例如：`tuling`（图灵微服务）\n\n> 命名空间创建后，所有属于该空间的镜像都会归类在此下，便于权限管理和团队协作。\n\n---\n\n### 3.2 登录阿里云镜像仓库\n\n**前置条件**：需先有阿里云账号，并开通容器镜像服务。\n\n执行登录命令（从阿里云控制台获取专属命令）：\n\n```bash\ndocker login --username=你的阿里云用户名 registry.cn-hangzhou.aliyuncs.com\n```\n\n- 输入密码后即可完成登录\n- 登录成功提示：`Login Succeeded`\n\n---\n\n### 3.3 给本地镜像打标签\n\n将本地镜像重新标记为符合阿里云仓库规范的格式：\n\n```bash\ndocker tag [本地镜像名:版本] registry.cn-hangzhou.aliyuncs.com/[命名空间]/[镜像名]:[版本]\n```\n\n**示例：**\n```bash\n# 假设本地已有镜像 tuling-mall:0.0.5\ndocker tag tuling-mall:0.0.5 registry.cn-hangzhou.aliyuncs.com/tuling/tuling-mall:0.0.5\n```\n\n**参数说明：**\n- 可使用镜像 ID 或 `镜像名:版本` 指定源镜像\n- 目标地址必须包含：Registry 域名 + 命名空间 + 镜像名 + 版本号\n\n---\n\n### 3.4 推送镜像到远程仓库\n\n执行推送命令：\n\n```bash\ndocker push registry.cn-hangzhou.aliyuncs.com/tuling/tuling-mall:0.0.5\n```\n\n**推送过程特点：**\n- 首次推送需要一定时间（取决于镜像大小和网络）\n- 阿里云国内节点速度较快\n- 推送完成后，可在控制台看到镜像已上传至对应命名空间\n\n---\n\n### 3.5 验证与拉取测试\n\n#### 3.5.1 控制台验证\n\n刷新阿里云容器镜像服务控制台，确认：\n- 命名空间 `tuling` 下出现新镜像 `tuling-mall`\n- 版本标签显示为 `0.0.5`\n\n#### 3.5.2 拉取镜像测试\n\n在其他机器（或本机先删除再拉取）执行：\n\n```bash\ndocker pull registry.cn-hangzhou.aliyuncs.com/tuling/tuling-mall:0.0.5\n```\n\n验证本地是否成功获取：\n```bash\ndocker images\n# 应显示 tuling-mall 镜像\n```\n\n#### 3.5.3 运行容器测试\n\n```bash\ndocker run -d \\\n  --name tuling-mall-test \\\n  -p 8788:8080 \\\n  registry.cn-hangzhou.aliyuncs.com/tuling/tuling-mall:0.0.5\n```\n\n**验证要点：**\n- `docker ps` 查看容器状态为 `Up`\n- 访问 `http://localhost:8788` 测试业务接口\n- 确认应用已从 Nacos 等配置中心正确加载配置\n\n---\n\n## 4. AI 总结\n\n本视频详细演示了如何将本地构建的 Docker 微服务镜像发布到**阿里云容器镜像服务（ACR）**，实现跨服务器的镜像共享与部署。核心流程可归纳为\"**登录 → 打标 → 推送 → 拉取 → 运行**\"五步：首先通过 `docker login` 认证阿里云仓库，使用 `docker tag` 将本地镜像标记为符合远程仓库规范的命名格式，再通过 `docker push` 上传至云端，最后在目标服务器通过 `docker pull` 获取并运行。该方案相比自建 Harbor 或直接使用 Docker Hub，具有**国内访问稳定、免运维、成本低廉**的优势，特别适合中小团队和个人开发者作为 CI/CD 流程中的镜像分发环节。掌握此技能后，可进一步结合 Jenkins、GitLab CI 等工具实现自动化构建与部署流水线。",
    "createdAt": "2026-02-20T04:15:13.843Z",
    "updatedAt": "2026-02-20T04:15:13.843Z"
  },
  {
    "id": "note_ca618d84b47e",
    "title": "【Docker】使用Dockerfile构建电商项目微服务镜像",
    "sourceUrl": "https://www.bilibili.com/video/BV1QV1xBBE6y?spm_id_from=333.788.videopod.episodes&vd_source=2a985ca1c3a6930df4b372bbf6082ce6&p=4",
    "contentMd": "# 【Docker】使用 Dockerfile 构建电商项目微服务镜像\n\n## 目录\n- [1. Dockerfile 基础概念](#1-dockerfile-基础概念)\n- [2. 构建第一个简单镜像](#2-构建第一个简单镜像)\n- [3. Dockerfile 常用指令详解](#3-dockerfile-常用指令详解)\n- [4. Java 应用镜像构建要点](#4-java-应用镜像构建要点)\n\n---\n\n## 1\\. Dockerfile 基础概念\n\n**Dockerfile** 是一个文本文件，其中包含了若干条指令，用于描述构建 Docker 镜像的细节。通过 Dockerfile，可以自动化地构建出包含特定环境和应用的镜像。\n\n---\n\n## 2\\. 构建第一个简单镜像\n\n### 2\\.1 创建示例目录与文件\n\n```bash\n# 创建项目目录\nmkdir docker-demo\ncd docker-demo\n\n# 创建 Dockerfile 文件（注意：无后缀名）\ntouch Dockerfile\n```\n\n### 2\\.2 编写基础 Dockerfile\n\n以下是一个修改 Nginx 镜像首页的简单示例：\n\n```dockerfile\nFROM nginx\nRUN echo '<h1>This is Tuling Nginx!!!</h1>' > /usr/share/nginx/html/index.html\n```\n\n| 指令 | 说明 |\n|:---|:---|\n| `FROM nginx` | 指定基础镜像为官方 Nginx 镜像 |\n| `RUN echo ...` | 执行 shell 命令，将自定义内容写入 Nginx 默认首页 |\n\n### 2\\.3 构建镜像\n\n```bash\n# 语法：docker build -t <镜像名>:<标签> <Dockerfile所在路径>\ndocker build -t nginx:tuling .\n```\n\n- `-t`：指定镜像名称和标签（tag）\n- `.`：表示当前目录（Dockerfile 所在路径）\n\n### 2\\.4 验证与运行\n\n```bash\n# 查看本地镜像列表\ndocker images | grep nginx\n\n# 运行容器（映射端口 93）\ndocker run -d -p 93:80 nginx:tuling\n\n# 查看运行中的容器\ndocker ps\n```\n\n访问 `http://<服务器IP>:93` 即可看到自定义的 Nginx 首页内容。\n\n---\n\n## 3\\. Dockerfile 常用指令详解\n\n| 指令 | 功能说明 | 典型应用场景 |\n|:---|:---|:---|\n| `FROM` | 指定基础镜像 | 所有 Dockerfile 必须以 FROM 开头 |\n| `RUN` | 执行命令并创建新的镜像层 | 安装软件包、修改配置文件 |\n| `COPY` | 从宿主机复制文件到镜像 | 将应用代码、配置文件复制到镜像 |\n| `ADD` | 类似 COPY，支持自动解压和 URL 下载 | 复制 tar 压缩包或远程文件 |\n| `CMD` | 容器启动时执行的默认命令 | 指定应用启动脚本或命令 |\n| `ENTRYPOINT` | 配置容器启动时的可执行程序 | 与 CMD 配合实现固定启动逻辑 |\n| `ENV` | 设置环境变量 | 配置 Java 环境变量、数据库连接等 |\n| `EXPOSE` | 声明容器暴露的端口 | 文档说明，实际映射需用 `-p` 参数 |\n| `VOLUME` | 创建挂载点 | 数据持久化存储 |\n| `WORKDIR` | 设置工作目录 | 指定后续指令的执行路径 |\n\n---\n\n## 4\\. Java 应用镜像构建要点\n\n对于 Java 微服务项目，Dockerfile 需要特别关注以下方面：\n\n### 4\\.1 基础镜像选择\n\n```dockerfile\n# 推荐使用官方 OpenJDK 基础镜像\nFROM openjdk:8-jdk-alpine\n# 或指定具体版本\nFROM openjdk:11-jre-slim\n```\n\n### 4\\.2 典型 Java 应用 Dockerfile 结构\n\n```dockerfile\n# 1. 指定基础镜像（Java 运行环境）\nFROM openjdk:8-jdk-alpine\n\n# 2. 设置工作目录\nWORKDIR /app\n\n# 3. 复制应用 JAR 包到镜像\nCOPY target/my-application.jar app.jar\n\n# 4. 暴露应用端口\nEXPOSE 8080\n\n# 5. 定义启动命令\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n```\n\n### 4\\.3 关键注意事项\n\n- **基础镜像必要性**：Java 应用必须依赖 JDK/JRE 环境，因此 `FROM` 指令后必须跟 Java 基础镜像\n- **JAR 包复制**：使用 `COPY` 或 `ADD` 将编译好的 JAR 包从宿主机复制到镜像中\n- **启动命令**：使用 `CMD` 或 `ENTRYPOINT` 指定 `java -jar` 启动命令\n- **链路追踪支持**：如需接入 SkyWalking 等 APM 工具，需在启动命令中添加相关 agent 参数\n\n---\n\n## AI 总结\n\n本视频系统讲解了如何使用 Dockerfile 构建 Docker 镜像，从最简单的 Nginx 首页修改示例入手，逐步深入到 Java 微服务项目的镜像构建实践。核心要点包括：**Dockerfile 的基础指令（FROM、RUN、COPY、CMD 等）**、**镜像构建命令 `docker build`**、以及 **Java 应用镜像的特殊考量（基础镜像选择、JAR 包部署、启动命令配置）**。掌握这些技能是云原生时代后端开发工程师的必备能力，能够有效实现应用的标准化打包与交付，为后续的容器编排（Kubernetes）和 CI/CD 流水线奠定基础。",
    "createdAt": "2026-02-20T04:15:13.823Z",
    "updatedAt": "2026-02-20T04:15:13.823Z"
  },
  {
    "id": "note_0190cb3785c3",
    "title": "【Docker】docker使用",
    "sourceUrl": "https://www.bilibili.com/video/BV1QV1xBBE6y?spm_id_from=333.788.videopod.episodes&vd_source=2a985ca1c3a6930df4b372bbf6082ce6&p=3",
    "contentMd": "# Docker 基础使用详解\n\n## 目录\n- [1. Docker 环境检查与帮助命令](#1-docker-环境检查与帮助命令)\n- [2. Docker 镜像管理](#2-docker-镜像管理)\n  - [2.1 搜索镜像](#21-搜索镜像)\n  - [2.2 拉取镜像](#22-拉取镜像)\n  - [2.3 查看与管理镜像](#23-查看与管理镜像)\n- [3. Docker 容器操作](#3-docker-容器操作)\n  - [3.1 运行容器](#31-运行容器)\n  - [3.2 网络模式详解](#32-网络模式详解)\n  - [3.3 容器状态管理](#33-容器状态管理)\n  - [3.4 容器信息查看与调试](#34-容器信息查看与调试)\n  - [3.5 进入容器内部](#35-进入容器内部)\n- [4. 中间件部署实践](#4-中间件部署实践)\n- [5. AI 总结](#5-ai-总结)\n\n---\n\n## 1\\. Docker 环境检查与帮助命令\n\n安装完成后，首先验证 Docker 环境：\n\n```bash\ndocker --version    # 查看版本，示例输出：24.0.2\ndocker              # 查看所有相关命令\n```\n\nDocker 命令分为两大类：\n- **镜像相关命令**（`docker image` 子命令）\n- **容器相关命令**（`docker container` 子命令）\n\n> 提示：任何命令不记得时，直接使用 `docker` 或 `docker <command> --help` 查看帮助文档。\n\n---\n\n## 2\\. Docker 镜像管理\n\n### 2.1 搜索镜像\n\n使用 `docker search` 从 Docker Hub 搜索镜像：\n\n```bash\ndocker search java        # 搜索 Java 相关镜像\ndocker search nginx       # 搜索 Nginx 镜像\ndocker search mongo       # 搜索 MongoDB 镜像\n```\n\n**选择镜像的原则**：\n| 指标 | 说明 |\n|:---|:---|\n| **STARS** | 星标数越高，使用人数越多，越可靠 |\n| **OFFICIAL** | `[OK]` 标记表示官方镜像，优先选择 |\n| **AUTOMATED** | 自动构建的镜像 |\n\n> 注意：Docker Hub 官方仓库在国内访问可能需要科学上网，也可搭建私有仓库或使用国内镜像源。\n\n### 2.2 拉取镜像\n\n```bash\ndocker pull nginx                    # 拉取最新版本（latest）\ndocker pull nginx:1.24               # 拉取指定版本\ndocker pull openjdk:8-jdk            # 拉取 OpenJDK 8\ndocker pull mongo:latest             # 拉取 MongoDB\n```\n\n**镜像版本选择**：在 Docker Hub 页面可查看：\n- 所有可用版本标签（Tags）\n- 镜像构建的 Dockerfile 内容\n- 镜像使用说明和启动命令\n\n### 2.3 查看与管理镜像\n\n```bash\ndocker images           # 列出本地所有镜像\ndocker rmi <image_id>   # 删除指定镜像（rmi = remove image）\n```\n\n`docker images` 输出字段说明：\n- **REPOSITORY**：镜像名称\n- **TAG**：版本标签\n- **IMAGE ID**：镜像唯一标识\n- **CREATED**：创建时间\n- **SIZE**：镜像大小\n\n---\n\n## 3\\. Docker 容器操作\n\n### 3.1 运行容器\n\n**基础命令格式**：\n```bash\ndocker run [选项] 镜像名 [命令]\n```\n\n**常用参数详解**：\n\n| 参数 | 全称 | 说明 |\n|:---|:---|:---|\n| `-d` | `--detach` | 后台运行容器 |\n| `-p` | `--publish` | 端口映射，格式：`宿主机端口:容器端口` |\n| `--name` | | 为容器指定名称 |\n| `--network` | | 指定网络模式 |\n\n**Nginx 部署示例**：\n```bash\ndocker run -d \\\n  -p 911:80 \\\n  --name my-nginx \\\n  nginx\n```\n\n**参数解析**：\n- `-d`：后台守护进程方式运行\n- `-p 911:80`：将宿主机的 911 端口映射到容器的 80 端口\n  - 外部访问 `http://宿主机IP:911` → 转发到容器内部的 80 端口\n- 若本地无该镜像，Docker 会自动从远程仓库拉取\n\n**多实例快速部署**：\n```bash\ndocker run -d -p 912:80 nginx    # 第二个 Nginx 实例，映射到 912 端口\n```\n\n### 3.2 网络模式详解\n\n通过 `--network` 参数指定，默认为 `bridge` 模式。\n\n#### ① Bridge 模式（默认）\n\n```bash\ndocker run -d -p 911:80 nginx           # 默认即 bridge\n# 或显式指定\ndocker run -d -p 911:80 --network bridge nginx\n```\n\n**特点**：\n- Docker 会创建虚拟网卡 `docker0`（或 `dockerNin`）\n- 容器通过该网卡与宿主机、其他容器通信\n- 容器拥有独立的网络命名空间\n\n**验证网络配置**：\n```bash\nip addr          # 宿主机上查看，可见 docker0 网卡\n```\n\n容器运行后会新增虚拟网卡，与 `docker0` 建立桥接关系。\n\n#### ② Host 模式\n\n```bash\ndocker run -d --network host nginx\n```\n\n**特点**：\n- 容器直接使用宿主机的网络栈，无独立 IP\n- 容器端口直接占用宿主机端口（无需 `-p` 映射）\n- 性能最优，但端口冲突风险高\n\n**适用场景**：不考虑网络隔离，追求极致性能时使用。\n\n#### ③ Container 模式\n\n```bash\ndocker run -d --network container:<目标容器名> <镜像>\n```\n\n**特点**：\n- 新容器与指定目标容器共享网络命名空间\n- 两者处于同一\"局域网\"，可直接通过 localhost 通信\n\n**典型应用场景**：\n- Elasticsearch + Kibana + Logstash（ELK 栈）\n- 多个微服务组件需要紧密网络耦合时\n\n### 3.3 容器状态管理\n\n```bash\n# 查看运行中的容器\ndocker ps\n\n# 查看所有容器（包括已停止）\ndocker ps -a\n\n# 停止容器\ndocker stop <容器ID或名称>\n\n# 启动已停止的容器\ndocker start <容器ID或名称>\n\n# 重启容器\ndocker restart <容器ID或名称>\n\n# 删除容器（需先停止）\ndocker rm <容器ID或名称>\n\n# 强制删除运行中容器\ndocker rm -f <容器ID或名称>\n```\n\n### 3.4 容器信息查看与调试\n\n```bash\n# 查看容器日志\ndocker logs <容器ID>\n\n# 查看容器详细信息（JSON 格式）\ndocker inspect <容器ID>\n```\n\n`docker inspect` 关键信息：\n- 容器完整 ID、创建时间、状态\n- 端口映射详情（`NetworkSettings.Ports`）\n- 容器内部 IP 地址（排查网络问题时非常有用）\n- 挂载卷、环境变量等配置\n\n```bash\n# 从容器复制文件到宿主机\ndocker cp <容器ID>:/容器内路径 /宿主机路径\n\n# 从宿主机复制文件到容器\ndocker cp /宿主机路径 <容器ID>:/容器内路径\n```\n> 实际生产环境推荐使用 **数据卷挂载**（`-v` 参数），而非 `cp` 命令。\n\n### 3.5 进入容器内部\n\n```bash\ndocker exec -it <容器ID> /bin/bash\n```\n\n**参数说明**：\n- `-i`（`--interactive`）：保持标准输入打开\n- `-t`（`--tty`）：分配伪终端\n\n**容器内操作注意事项**：\n- 部分精简镜像可能未安装 `bash`，可尝试 `/bin/sh`\n- 某些命令如 `ll` 可能不存在，但 `ls`、`cd`、`pwd` 等基本命令通常可用\n- 可在容器内安装所需工具（如 `vim`、`curl` 等）\n\n---\n\n## 4\\. 中间件部署实践\n\nDocker 部署各类中间件的通用方法：\n\n| 中间件 | 参考来源 | 关键要点 |\n|:---|:---|:---|\n| **MySQL** | Docker Hub 官方文档 | 需配置 root 密码、数据持久化卷 |\n| **MongoDB** | 官方镜像页面 | 社区版（Community Edition）一键启动 |\n| **Redis** | 官方镜像 | 注意配置文件挂载 |\n| **Nacos** | 官方文档 | 需配置数据库连接 |\n| **RabbitMQ/Kafka** | 官方镜像 | 注意端口映射（管理界面+服务端口）|\n\n**MongoDB 快速启动示例**：\n```bash\ndocker run -d \\\n  -p 27017:27017 \\\n  --name mongodb \\\n  mongo:latest\n```\n\n**学习建议**：\n1. 优先查阅 **Docker Hub 官方镜像页面** 的文档\n2. 关注镜像的 **Stars 数** 和 **更新频率**\n3. 复杂场景参考 **Docker Compose** 编排方案\n\n---\n\n## 5\\. AI 总结\n\n本视频系统讲解了 Docker 的基础使用流程，涵盖从环境验证、镜像搜索拉取、到容器运行管理的完整操作链。核心要点包括：**掌握 `docker search/pull/images/rmi` 等镜像生命周期命令**；**理解 `docker run` 的 `-d`、`-p`、`--network` 等关键参数**，特别是三种网络模式（Bridge/Host/Container）的适用场景；**熟练运用 `ps/start/stop/rm/logs/inspect/exec` 等容器运维命令**。讲师通过 Nginx 多实例部署演示了 Docker 的快速交付能力，并强调学习中间件部署时应以官方文档为首要参考。视频最后预告了后续内容：构建自定义镜像并将应用打包部署，这是从\"使用 Docker\"迈向\"基于 Docker 开发\"的关键进阶。",
    "createdAt": "2026-02-20T04:15:13.799Z",
    "updatedAt": "2026-02-20T04:15:13.799Z"
  },
  {
    "id": "note_fe17436c0173",
    "title": "【Docker】基于cento7安装docker",
    "sourceUrl": "https://www.bilibili.com/video/BV1QV1xBBE6y?spm_id_from=333.788.videopod.episodes&vd_source=2a985ca1c3a6930df4b372bbf6082ce6&p=2",
    "contentMd": "# Docker 基于 CentOS 7 安装与配置实战\n\n## 目录\n- [1. Docker 版本介绍](#1-docker-版本介绍)\n- [2. 环境准备与前置检查](#2-环境准备与前置检查)\n- [3. Docker CE 安装步骤](#3-docker-ce-安装步骤)\n- [4. 配置阿里云镜像加速器](#4-配置阿里云镜像加速器)\n- [5. 后续学习规划](#5-后续学习规划)\n\n---\n\n## 1\\. Docker 版本介绍\n\nDocker 作为开源的商业产品，提供两个主要版本：\n\n| 版本 | 说明 |\n|:---|:---|\n| **社区版 (CE, Community Edition)** | 免费开源，适合个人开发者和小型团队使用 |\n| **企业版 (EE, Enterprise Edition)** | 包含额外收费服务，如高级安全、官方支持等 |\n\n**推荐选择**：个人学习和一般开发场景使用 **Docker CE** 即可满足需求。\n\n> 官方安装文档参考：[Docker 官方文档](https://docs.docker.com/engine/install/)\n\n---\n\n## 2\\. 环境准备与前置检查\n\n### 2\\.1 操作系统要求\n\n- **演示环境**：CentOS 7（x86_64 架构）\n- **内核版本硬性要求**：必须 **≥ 3.10**\n\n```bash\n# 查看当前系统内核版本\nuname -r\n```\n\n若内核版本低于 3.10，需先升级操作系统内核。\n\n### 2\\.2 旧版本检查与卸载\n\n```bash\n# 检查是否已安装 Docker\ndocker --version\n\n# 若存在旧版本，建议先卸载再安装新版本\nyum remove docker \\\n           docker-client \\\n           docker-client-latest \\\n           docker-common \\\n           docker-latest \\\n           docker-latest-logrotate \\\n           docker-logrotate \\\n           docker-engine\n```\n\n---\n\n## 3\\. Docker CE 安装步骤\n\n### 3\\.1 更新 yum 包索引\n\n```bash\n# 确保 yum 包管理器为最新状态\nyum update -y\n```\n\n### 3\\.2 安装必要依赖包\n\n```bash\n# 安装 yum-utils 等工具包\nyum install -y yum-utils device-mapper-persistent-data lvm2\n```\n\n### 3\\.3 添加阿里云 Docker 软件源\n\n```bash\n# 配置阿里云 yum 源（关键步骤）\nyum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n```\n\n### 3\\.4 查看可用版本列表\n\n```bash\n# 列出仓库中所有可用的 Docker CE 版本\nyum list docker-ce --showduplicates | sort -r\n```\n\n输出示例中包含类似 `docker-ce.x86_64 24.0.2-1.el7` 的版本信息。\n\n### 3\\.5 指定版本安装\n\n**版本命名规则**：`docker-ce-<VERSION>.<OS_RELEASE>.<ARCH>`\n\n```bash\n# 安装指定版本（示例：24.0.2）\nyum install -y docker-ce-24.0.2-1.el7.x86_64\n```\n\n或直接安装最新稳定版：\n```bash\nyum install -y docker-ce docker-ce-cli containerd.io\n```\n\n### 3\\.6 启动并设置开机自启\n\n```bash\n# 启动 Docker 服务\nsystemctl start docker\n\n# 设置开机自动启动\nsystemctl enable docker\n\n# 验证安装结果\ndocker version\ndocker info\n```\n\n---\n\n## 4\\. 配置阿里云镜像加速器\n\n### 4\\.1 为什么需要加速器？\n\n- Docker 默认从 **Docker Hub**（国外仓库）拉取镜像\n- 国内访问速度极慢，严重影响开发效率\n- **解决方案**：配置阿里云镜像加速器（免费）\n\n### 4\\.2 获取加速器地址\n\n1. 登录 [阿里云容器镜像服务](https://cr.console.aliyun.com/)\n2. 选择 **个人版**（免费）\n3. 进入 **镜像工具 → 镜像加速器**\n4. 复制专属加速器地址（格式：`https://<your_id>.mirror.aliyuncs.com`）\n\n### 4\\.3 配置加速器（CentOS 7）\n\n```bash\n# 创建或修改 Docker 守护进程配置文件\nsudo mkdir -p /etc/docker\n\n# 写入加速器配置\nsudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://<your_id>.mirror.aliyuncs.com\"]\n}\nEOF\n\n# 重新加载配置并重启 Docker\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n### 4.4 阿里云镜像服务扩展功能\n\n| 功能 | 说明 |\n|:---|:---|\n| **镜像加速器** | 加速 Docker Hub 镜像下载 |\n| **个人镜像仓库** | 免费托管自定义镜像 |\n| **微服务镜像管理** | 将项目打包的镜像推送至私有仓库 |\n\n---\n\n## 5\\. 后续学习规划\n\n完成 Docker 安装后，视频课程将继续讲解：\n\n1. **Docker 基础使用**\n   - 搜索镜像：`docker search`\n   - 运行容器：以 Nginx 为例\n\n2. **Dockerfile 构建镜像**\n   - 编写 Dockerfile 文件\n   - 构建自定义镜像\n\n3. **电商项目实战**\n   - 微服务项目打包成镜像\n   - 镜像运行与部署\n   - 私有仓库发布与管理\n\n---\n\n## AI 总结\n\n本视频详细演示了在 CentOS 7 环境下安装 Docker CE 的完整流程，涵盖版本选择、内核检查、yum 源配置、指定版本安装、服务启动及阿里云镜像加速器配置等关键步骤。核心要点包括：**内核版本必须 ≥ 3.10**、**推荐使用阿里云 yum 源加速安装**、**务必配置镜像加速器解决国内下载慢的问题**。整个安装过程逻辑清晰，命令可复制性强，适合 Linux 初学者跟随操作。后续课程将延伸至 Dockerfile 构建、微服务容器化部署等实战内容，形成从安装到生产应用的完整知识链路。",
    "createdAt": "2026-02-20T04:15:13.774Z",
    "updatedAt": "2026-02-20T04:15:13.774Z"
  },
  {
    "id": "note_979fef684cf5",
    "title": "【Docker】docker的设计理念与架构分析",
    "sourceUrl": "https://www.bilibili.com/video/BV1QV1xBBE6y?spm_id_from=333.788.videopod.episodes&vd_source=2a985ca1c3a6930df4b372bbf6082ce6",
    "contentMd": "# Docker 设计理念与架构分析\n\n## 目录\n- [1. 课程背景与定位](#1-课程背景与定位)\n- [2. 云原生部署的挑战](#2-云原生部署的挑战)\n- [3. Docker 核心概念](#3-docker-核心概念)\n- [4. Docker vs 传统虚拟机](#4-docker-vs-传统虚拟机)\n- [5. Docker 架构组成](#5-docker-架构组成)\n- [6. 镜像与容器的工作流程](#6-镜像与容器的工作流程)\n- [7. 课程后续安排](#7-课程后续安排)\n- [AI 总结](#ai-总结)\n\n---\n\n## 1\\. 课程背景与定位\n\n**讲师**：图灵课堂 Fox 老师  \n**课程主题**：Docker 技术详解与微服务部署实战  \n**前置知识**：已学完 Java 新特性篇，进入云原生应用部署阶段\n\n### 1\\.1 本节课目标人群\n- **有 Docker 基础的同学**：可跳过本节，直接进入 `Docker Compose` 部署微服务部分\n- **无 Docker 基础的同学**：需掌握本节基础概念后再学习后续内容\n\n### 1\\.2 微服务部署的两种方式\n| 方式 | 适用场景 | 特点 |\n|:---|:---|:---|\n| **Docker + Docker Compose** | 中小型公司、资源有限环境 | 轻量级、快速上手、单机多容器管理 |\n| **Kubernetes (K8S)** | 大型互联网公司 | 大规模集群编排、大厂首选 |\n\n---\n\n## 2\\. 云原生部署的挑战\n\n### 2\\.1 传统部署方式的痛点\n\n**中间件部署复杂度高**\n- Redis、MongoDB、RocketMQ、Kafka、Elasticsearch 等需要逐个手动搭建\n- 部分组件（如 Elasticsearch）需要修改操作系统内核参数：\n  - 线程数限制 (`vm.max_map_count`)\n  - Socket 连接数配置\n  - 文件描述符限制\n\n**虚拟机资源瓶颈**\n- 个人开发机配置通常为 8核16G，无法同时运行多台虚拟机\n- 示例：部署 ZooKeeper 三节点集群需要 3 台虚拟机，资源消耗过大\n\n**微服务扩容困难**\n- 传统脚本部署方式无法应对快速扩缩容需求\n- 100+ 服务的部署和运维成为瓶颈\n\n---\n\n## 3\\. Docker 核心概念\n\n### 3\\.1 定义\n> **Docker** 是一个开源的容器化平台，帮助开发者将应用程序及其依赖环境打包成**可移植、可部署的容器**。\n\n### 3\\.2 核心理念\n```\n一次构建，到处运行（Build Once, Run Anywhere）\n```\n\n- 将应用 + 运行环境 + 依赖库统一打包为**镜像（Image）**\n- 无需重复配置环境，一条命令即可启动应用\n\n### 3.3 本质特征\n| 特性 | 说明 |\n|:---|:---|\n| **容器化技术** | 进程级隔离，非硬件虚拟化 |\n| **轻量级** | 共享宿主机操作系统内核 |\n| **快速启动** | 秒级启动（对比虚拟机的分钟级） |\n| **弹性伸缩** | 快速复制、扩展容器实例 |\n| **环境一致性** | 开发/测试/生产环境完全一致 |\n\n---\n\n## 4\\. Docker vs 传统虚拟机\n\n### 4.1 架构对比\n\n| 维度 | 传统虚拟机 (VM) | Docker 容器 |\n|:---|:---|:---|\n| **虚拟化层级** | 硬件级虚拟化 | 操作系统级虚拟化（进程级） |\n| **资源占用** | 高（需分配独立 CPU、内存、磁盘） | 低（共享宿主机内核） |\n| **启动速度** | 分钟级 | 秒级 |\n| **性能损耗** | 10-20% | 接近原生（<5%） |\n| **隔离性** | 强（完全隔离） | 进程级隔离（足够安全） |\n| **部署密度** | 单台机器 10-20 个 | 单台机器 100+ 个 |\n\n### 4.2 工作流程对比\n\n**传统虚拟机部署 ZooKeeper 集群**\n```\n物理机 → Hypervisor → VM1(ZK节点1)\n                  → VM2(ZK节点2)  \n                  → VM3(ZK节点3)\n[每台VM需独立OS，资源消耗大]\n```\n\n**Docker 部署 ZooKeeper 集群**\n```\n物理机 → Docker Engine → Container 1 (ZK节点1)\n                       → Container 2 (ZK节点2)\n                       → Container 3 (ZK节点3)\n[共享宿主机OS，轻量高效]\n```\n\n---\n\n## 5\\. Docker 架构组成\n\nDocker 采用 **C/S（客户端-服务器）架构**，包含三大核心组件：\n\n```\n┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐\n│   Docker Hub    │◄────│   Docker CLI    │     │  Docker Daemon  │\n│  (镜像仓库)      │     │  (命令行客户端)  │────►│  (守护进程/引擎) │\n│                 │     │                 │     │                 │\n│ • 官方镜像       │     │ docker pull     │     │ • 镜像管理       │\n│ • 私有仓库       │     │ docker run      │     │ • 容器生命周期   │\n│ • 版本控制       │     │ docker build    │     │ • 网络/存储管理  │\n└─────────────────┘     └─────────────────┘     └─────────────────┘\n                              │\n                              ▼\n                        ┌─────────────┐\n                        │   Images    │\n                        │   (镜像)     │\n                        └─────────────┘\n                              │\n                              ▼\n                        ┌─────────────┐\n                        │ Containers  │\n                        │   (容器)     │\n                        └─────────────┘\n```\n\n### 5.1 核心组件详解\n\n| 组件 | 功能 | 关键命令 |\n|:---|:---|:---|\n| **Docker Registry（镜像仓库）** | 存储和分发 Docker 镜像 | `docker push`, `docker pull` |\n| **Docker Daemon（守护进程）** | 管理容器生命周期、镜像构建、网络存储 | 后台运行 |\n| **Docker CLI（客户端）** | 用户与 Docker 交互的命令行接口 | `docker` 系列命令 |\n\n### 5.2 常用镜像仓库\n- **Docker Hub**：官方公共仓库，包含大量官方镜像（Redis、Nginx、MySQL 等）\n- **阿里云容器镜像服务**：国内加速，支持私有仓库\n- **Harbor**：企业级私有镜像仓库\n\n---\n\n## 6\\. 镜像与容器的工作流程\n\n### 6.1 完整生命周期\n\n```\n开发阶段                    交付阶段                    运行阶段\n┌─────────┐                ┌─────────┐                ┌─────────┐\n│ 编写代码 │───►│ 构建镜像 │───►│ 推送仓库 │───►│ 拉取镜像 │───►│ 运行容器 │\n│ Dockerfile│               │ docker  │                │ docker  │                │ docker  │\n│         │                │  build  │                │  push   │                │  pull   │\n└─────────┘                └─────────┘                └─────────┘                └─────────┘\n                                                                                      │\n                                                                                      ▼\n                                                                                ┌─────────┐\n                                                                                │ docker  │\n                                                                                │  run    │\n                                                                                │ (启动容器)│\n                                                                                └─────────┘\n```\n\n### 6.2 关键操作示例\n\n| 操作 | 命令 | 说明 |\n|:---|:---|:---|\n| 搜索镜像 | `docker search java` | 在 Docker Hub 查找镜像 |\n| 拉取镜像 | `docker pull redis` | 下载镜像到本地 |\n| 运行容器 | `docker run redis` | 基于镜像启动容器 |\n| 查看镜像 | `docker images` | 列出本地镜像 |\n| 查看容器 | `docker ps` | 列出运行中的容器 |\n\n### 6.3 典型应用场景\n\n**快速搭建 Redis 集群**\n```bash\n# 传统方式：准备3台虚拟机，逐台安装配置\n# Docker方式：单条命令启动3个实例\ndocker run -d --name redis-1 redis\ndocker run -d --name redis-2 redis  \ndocker run -d --name redis-3 redis\n```\n\n---\n\n## 7\\. 课程后续安排\n\n### 7.1 即将覆盖的内容\n1. **Docker 安装与基础命令**（CentOS 环境）\n2. **Dockerfile 构建自定义镜像**\n3. **Docker Compose 编排微服务**\n4. **私有镜像仓库搭建与镜像推送**\n\n### 7.2 学习建议\n> 虽然 Docker 安装简单（\"一条命令搞定\"），但务必掌握：\n> - 安装过程中的常见问题排查\n> - 镜像构建的最佳实践\n> - 容器网络与数据持久化机制\n\n---\n\n## AI 总结\n\n本视频作为 Docker 技术入门的第一课，系统阐述了 Docker 在云原生时代的核心价值。讲师从微服务部署的实际痛点出发，对比了传统虚拟机与容器技术的本质差异，揭示了 Docker \"一次构建，到处运行\"的设计理念。关键要点包括：Docker 通过进程级虚拟化实现轻量级隔离，显著降低资源开销并提升启动速度；其 C/S 架构由镜像仓库、守护进程和客户端三部分组成，形成完整的镜像分发与容器运行体系。对于学习者而言，理解 Docker 与传统虚拟机的架构差异是掌握容器技术的关键——容器并非迷你虚拟机，而是共享宿主机内核的隔离进程。后续课程将围绕镜像构建、Compose 编排和私有仓库展开，为微服务部署奠定坚实基础。",
    "createdAt": "2026-02-20T04:15:13.750Z",
    "updatedAt": "2026-02-20T04:15:13.750Z"
  },
  {
    "id": "note_31db293d67ad",
    "title": "从传统编程转向大模型编程 | BestBlogs.dev",
    "sourceUrl": "https://www.bestblogs.dev/article/bc19b98b",
    "contentMd": "# 从传统编程转向大模型编程\n\n## 目录\n- [0. 核心目标：从\"代码产出者\"变成\"文档定义者\"](#0-核心目标从代码产出者变成文档定义者)\n- [1. 为什么要用大模型编程？](#1-为什么要用大模型编程)\n- [2. 人 + AI 结对编程：角色与好处](#2-人--ai-结对编程角色与好处)\n- [3. 模型、工具与技巧](#3-模型工具与技巧)\n- [4. 基于文档的开发流程 (Spec-Driven Development)](#4-基于文档的开发流程-spec-driven-development)\n- [5. 常见陷阱与对应策略](#5-常见陷阱与对应策略)\n- [6. 安全与合规：模型接力与仓库分级](#6-安全与合规模型接力与仓库分级)\n- [7. 你的责任：流程设计者，而不仅是代码作者](#7-你的责任流程设计者而不仅是代码作者)\n- [附录：常见疑问 FAQ](#附录常见疑问-faq)\n\n---\n\n## 0. 核心目标：从\"代码产出者\"变成\"文档定义者\"\n\n这篇文档的核心不是教你怎么把 Ctrl+C / Ctrl+V 换成\"让 AI 写代码\"，而是希望帮你完成一次根本性的角色转换：\n\n> **Code is generated, Document is the Source of Truth（代码是生成的，文档才是真理之源）**\n\n| 维度 | 以前 | 以后 |\n|:---|:---|:---|\n| **核心产出** | `FunctionImpl`（函数实现） | `RequirementSpec` + `ArchitectureDesign`（需求规格 + 架构设计） |\n| **文档角色** | 代码的\"解释说明\"（经常过期） | 定义核心意图，AI 据此\"编译\"生成代码 |\n| **工作重心** | 亲自砌砖（写代码） | 画图纸（设计）+ 监管施工（验收） |\n\n### 人力投入的新分配\n\n在安全合规前提下，把\"写代码\"变成自动化生成过程，人力主要花在：\n\n- **需求澄清与拆解** —— 把模糊的想法变成清晰的文档\n- **架构与边界设计** —— 定义 AI 的活动范围\n- **文档对齐与验收** —— 检查代码是否忠实实现了文档\n\n### 预期带来的具体变化\n\n- **文档即代码**：修改功能不再是\"改代码 → 改文档\"，而是\"改文档 → AI 重写代码\"\n- **模型无关性**：文档写得够细，用 GPT 还是 Qwen 区别只在生成快慢，不会偏离核心逻辑\n- **知识资产化**：团队沉淀的是清晰可复用的业务逻辑文档，而非只有原作者能看懂的代码\n\n> 不管你是程序员、测试、产品还是设计师，今天都应该**大用特用大模型写代码和文档**——越早融入日常工作，越不容易被\"会用 AI 的人\"替代。\n\n---\n\n## 1. 为什么要用大模型编程？\n\n大模型编程（LLM-based Programming）的核心变化，是从关注 **\"怎么做（How）\"** 转向 **\"需要什么（What）\"**。\n\n### 1\\.1 一个真实的转变经历\n\n| 时间节点 | 状态 |\n|:---|:---|\n| **2023 年初（微软时期）** | GPT 刚兴起，Copilot 只能添加注释、生成简单单元测试，离真正\"会写代码\"差距很大 |\n| **2024 年底** | 已能用 Cursor 完成几乎所有编码任务，过去一年几乎没有真正\"手写\"过代码 |\n| **加入钉钉后** | 无 Java 工程经验，仍能快速完成开发需求，产出代码质量高且风格一致 |\n\n> **确信**：未来一定是大模型编码的世界，学习大模型编程会像学习使用 IDE 一样，成为最基本的工程师技能。\n\n### 1\\.2 AI 编程带来的典型变化\n\n| 场景 | 传统方式 | AI 辅助方式 |\n|:---|:---|:---|\n| 从零开始新功能 | 查阅文档 → 手写骨架 → 逐步填充 | 描述需求 → AI 生成完整模块 → Review & 调整 |\n| 理解陌生代码库 | 逐行阅读 + 打断点调试 | 让 AI 总结模块职责、关键流程、数据流 |\n| Bug 修复 | 复现 → 定位 → 修改 → 验证 | 贴错误日志 → AI 分析根因 → 生成修复方案 |\n| 代码重构 | 手动修改 + 担心破坏现有逻辑 | AI 生成重构计划 → 分步执行 → 自动回归测试 |\n| 编写技术文档 | 先写代码再补文档（常过期） | 先写文档 → AI 生成代码 → 文档即唯一真相源 |\n\n> 效率提升因人而异，关键是找到适合你的使用方式。\n\n---\n\n## 2. 人 + AI 结对编程：角色与好处\n\n传统结对编程：两名开发者协作，一人写代码（Driver），一人盯设计（Navigator）。\n\n**大模型时代的新型结对编程**：人 + 模型\n\n| 角色 | 人类（你） | AI 模型 |\n|:---|:---|:---|\n| **主要职责** | 把需求翻译成清晰的 Prompt 和约束；设计合理步骤；识别风险与幻觉 | 根据指令生成代码、测试、文档；执行重复性任务 |\n| **核心技能** | 需求拆解、架构设计、批判性 Review | 模式匹配、快速生成、多方案尝试 |\n\n### 2\\.1 会后可以立即尝试的三件事\n\n#### 第一次尝试：给现有函数补充单元测试\n\n```\n步骤：\n1. 选一个熟悉的、逻辑简单的函数\n2. 复制代码，对 AI 说：\"帮我为这个函数写 5 个覆盖边界情况的单元测试\"\n3. Review 生成的测试，修改不合理的 case\n4. 运行测试，根据失败情况调整\n\n关键点：明确说\"只写测试，不改实现\"\n```\n\n#### 第二次尝试：理解陌生代码模块\n\n```\n步骤：\n1. 找不熟悉但需要了解的模块\n2. 把核心类/函数代码给 AI，问：\"这个模块的主要职责是什么？关键流程是怎样的？\"\n3. 对比 AI 的回答和自己的理解\n\n关键点：把 AI 当成\"导游\"，快速建立宏观认知\n```\n\n#### 第三次尝试：编写技术方案文档\n\n```\n步骤：\n1. 准备好需求描述和关键技术点\n2. 让 AI 生成文档骨架：\"帮我写一份技术方案，包括背景、方案设计、风险和时间规划\"\n3. 补充业务细节和决策背景\n\n关键点：AI 负责结构化，你负责业务内容\n```\n\n> **预期时间**：每次 10-20 分钟，完成后你会对 AI 的能力边界有基本认知。\n\n### 2\\.2 新的工作节奏：利用\"认知缓冲\"对抗\"代码催眠\"\n\n**现象**：输入 Prompt 后，需要等待模型生成 30–60 秒，键盘敲击声变少了，\"等待\"时间变多了（称之为\"受迫性摸鱼\"）。\n\n**关键洞察**：这段\"空窗期\"不是浪费时间，而是必要的 **\"认知缓冲（Cognitive Buffer）\"**。\n\n**危险：代码催眠（Code Hypnosis）**\n- 大模型高速生成大量代码时，人类容易看着代码流淌觉得都对\n- 实则大脑麻木，失去批判性思维\n\n**建议：合法化等待时间**\n\n| 做法 | 具体操作 |\n|:---|:---|\n| **强制抽离** | AI 生成时，视线短暂离开屏幕或清空大脑，保持\"像看陌生人代码\"的敏锐度 |\n| **思维预演** | 跳出具体语法，在脑中预演逻辑的边界情况 |\n| **节奏切换** | 从\"连续高频输出\"转变为\"脉冲式的决策—休息—决策\" |\n\n> **团队共识**：不要用\"是否一直在敲键盘\"衡量工作饱和度。对着屏幕静默思考、进行\"认知重组\"的工程师，比被 AI 带着跑的工程师更能守住系统安全底线。\n\n---\n\n## 3. 模型、工具与技巧\n\n### 3\\.1 模型选择决策树\n\n**使用口诀**：安全第一，复杂度第二，成本第三\n\n**决策流程**：\n```\n1. 代码/数据是否敏感？\n   ├── 是（C3级）→ 必须使用内部合规模型\n   └── 否 → 进入下一步\n   \n2. 任务复杂度如何？\n   ├── 复杂（架构设计、跨模块重构）→ 选最强外部模型（Claude/GPT）\n   └── 简单（单函数实现、格式化）→ 进入下一步\n   \n3. 预算是否紧张？\n   ├── 是 → 选性价比模型（Qwen/Gemini Flash）\n   └── 否 → 选最强外部模型\n```\n\n**常见模型类型参考**：\n\n| 类型 | 代表模型 | 适用场景 |\n|:---|:---|:---|\n| 顶级推理 | Claude 4.5, GPT-5.1, Gemini 2.5 Pro | 复杂架构、深度 Debug、安全关键代码 |\n| 高性价比 | Qwen3 Coder, GLM-4.6, Gemini Flash | 日常编码、简单重构、批量生成 |\n| 内部合规 | 企业自研/私有化部署模型 | C3 级敏感代码、金融/政务场景 |\n\n**使用原则**：\n- 先看安全等级，再选模型\n- 不依赖单一模型的\"个人口碑\"，结合**当前任务 + 实测效果**选择\n\n### 3\\.2 常见工具形态\n\n| 形态 | 代表工具 | 特点 |\n|:---|:---|:---|\n| IDE 插件 | GitHub Copilot, Cursor, Kilo Code | 最自然的工作流，实时补全 |\n| CLI 工具 | Claude Code, Codex CLI, Aider | 适合批量处理、自动化脚本 |\n| Web 界面 | ChatGPT, Claude.ai, 通义千问 | 适合探索性对话、长文本分析 |\n| API 调用 | OpenAI API, Anthropic API | 集成到自建工具链 |\n\n**推荐组合示例**：\n- 非敏感仓库：VSCode + 外部高性能模型\n- C3 仓库：内部 CLI + 内部模型，不允许外发代码片段\n\n**中转站资源**（安全可控且舍得花钱时）：[OpenRouter](https://openrouter.ai/), [ZenMux](https://zenmux.ai/)\n\n### 3\\.3 提示词工程：个人 Prompt 模板\n\n为每个常用模型准备固定提示词文件（如 `claude.md`, `gpt.md`, `gemini.md`），会话开始时整体贴入。\n\n**实用模板结构**：\n\n| 部分 | 内容 |\n|:---|:---|\n| **引用文档** | 直接引用 URL 或文件路径（`@docs/spec.md`），不让 AI 依赖口述 |\n| **角色定义** | 结对工程师 / 架构师 / 文档助手等 |\n| **目标与范围** | 解决什么问题，允许/不允许碰哪些模块 |\n| **工作方式** | 先问再改、先给方案再写代码、必须生成测试等 |\n| **禁止事项** | 不允许拍脑袋造接口、不允许一次改太多文件、不允许忽略安全规则 |\n| **输出格式** | 列表、代码块、Diff、分步骤说明 |\n| **项目特定习惯** | 日志前缀风格、错误码规范、测试框架等 |\n\n> 大模型能力增强后，不再需要很长的人设式提示词，但**约束型和步骤型**提示词仍然高效。\n\n**优秀模板资源**：[cursor.directory](https://cursor.directory/), [awesome-chatgpt-prompts](https://github.com/f/awesome-chatgpt-prompts)\n\n### 3\\.4 进阶技巧：构建\"会自我进化\"的 SOP (Real-Time RL Lite)\n\n#### 核心概念：Claude Skill\n\nClaude Skill 是将\"大模型的思考逻辑\"（Prompt/SKILL.md）与\"传统代码的执行能力\"（Scripts）打包在一起的\"能力插件\"。\n\n**结构示例**：\n```\nmy-code-review-skill/\n├── SKILL.md          # 告诉 AI：先跑脚本，再根据日志写评语\n└── run_linter.py     # 实际干脏活累活的传统代码\n```\n\n**威力**：确定性逻辑写成脚本（传统编程），不确定性逻辑写成 Prompt（大模型编程），AI 自动调度。\n\n#### 让 Skill 自我进化\n\n**核心逻辑**：每次任务结束后，不只验收代码，还要验收 Skill 包本身。\n\n```\n操作流程：\n1. 执行 (Execute)：AI 读取 SKILL.md 并调用配套脚本执行任务\n2. 复盘 (Review)：任务失败时分析原因（脚本报错 / AI 理解有误）\n3. 进化 (Evolve)：\n   ├── 修大脑：修改 SKILL.md 的判断逻辑\n   └── 修手脚：直接优化脚本本身\n```\n\n**实战案例**：第一次 Claude Code 生成不带中文注释的代码，让它更新 Skill 文件后，SKILL.md 自动增加：\n> *Rule 5: All strictly business logic must have simplified Chinese comments explain the 'Why', not just the 'How'.*\n\n从此以后无需重复提醒，换模型、换新人，团队战斗力几分钟内恢复 80%。\n\n**极速版 Gemini.md 示例**：\n```\nProtocol Selection Rules\nFrom now on, please adhere to the following protocols based on the task type:\n\n- Medium/Large Code Tasks: Refer to @/Users/wuyue/Documents/RIPER-5.md\n- Small Code Tasks: Refer to @/Users/wuyue/Documents/RIPER-LITE.md  \n- Documentation Tasks: Refer to @/Users/wuyue/Documents/RIPER-DOC.md\n\nPlease try to communicate with me in Chinese as much as possible.\n```\n\n**更多 Skill 示例**：[awesome-claude-skills](https://github.com/ComposioHQ/awesome-claude-skills)\n\n---\n\n## 4. 基于文档的开发流程 (Spec-Driven Development)\n\n> **SDD 定义**：一种软件开发方法论，强调在编码前编写详细、结构化的规格说明书，采用分阶段方法：明确用户需求 → 创建技术方案 → 拆解为微小可审查任务 → 逐一实施。旨在通过清晰蓝图减少猜测和返工，提高代码质量、可控性和可预测性。\n\n**核心铁律**：**严禁在没有文档支撑的情况下直接修改代码。**\n\n### 4\\.1 核心理念：文档即源码 (Doc as Code)\n\n| 层级 | 内容 | 类比 |\n|:---|:---|:---|\n| **Source Code** | `requirements.md`, `api_spec.md`, `architecture_decision.md` | 源代码 |\n| **Compiled Binary** | `UserService.java`, `main.py` | 编译产物 |\n| **Compiler** | LLM (Claude, GPT, Qwen) | 编译器 |\n\n### 4\\.2 标准工作流 (The SDD Workflow)\n\n#### Phase 1: 意图定义与文档生成\n\n| 步骤 | 执行者 | 动作 |\n|:---|:---|:---|\n| Step 1 | Human | 提供简要意图和上下文：\"我想给结算流程增加 VIP 折扣，参考现有的 Coupon 逻辑\" |\n| Step 2 | AI - Architect Agent | 草拟详细技术文档，生成 `docs/tasks/vip-discount.md` |\n| Step 3 | Human - **Sign-off** | **核心环节！**阅读并修改文档，确保 AI 理解真实意图，**锁定后才能进入下一阶段** |\n\n> 这份文档就是对 AI 下达的\"法律指令\"。\n\n#### Phase 2: AI 编译 (AI Implementation)\n\n```\n动作：将文档喂给 AI\nPrompt：\"请阅读 feature-xxx.md，并严格按照其中的 Steps 生成代码\"\n结果：AI 生成代码 Diff 或直接修改文件\n```\n\n#### Phase 3: 文档验收 (Verification & Alignment)\n\n| 情况 | 错误做法 | 正确做法 |\n|:---|:---|:---|\n| 代码逻辑不对 | 直接动手改代码 / 只在对话框里骂 AI | 回到 `feature-xxx.md`，修改描述不清的地方，让 AI **\"重新编译\"** |\n\n**原因**：确保文档永远最新，下次（或换模型）仍能生成正确结果。\n\n### 4\\.3 Demo 示例一：用日志 + AI 做 Debug\n\n**环境**：内部项目，使用 iflow + Qwen3 coder\n\n**步骤**：\n1. **用大模型添加全流程日志** → AI 自动识别关键节点，插入结构化日志\n2. **推送代码并部署** → 大模型自动生成 commit、解决冲突\n3. **运行测试获取日志，再喂给大模型** → AI 分析日志定位问题\n\n### 4\\.4 Demo 示例二：从开源项目到\"文档 + 小改动\"\n\n**工具**：Claude Code + Claude 4.5, Codex + GPT 5.1, Kilo Code + Gemini 3 等\n\n| 步骤 | 操作 | 细节 |\n|:---|:---|:---|\n| 1 | 大模型 A 生成文档 | 花费约 8 分钟，注意 token 消耗 |\n| 2 | 提出修改需求，输出详细修改文档 | 明确变更范围和技术方案 |\n| 3 | 大模型 B 评审文档 | 评估文档是否足够、预判潜在问题 |\n| 4 | 大模型 A 根据意见修改文档 | 迭代优化 |\n| 5 | 大模型 B 实施代码 | 严格按文档执行 |\n| 6 | 多模型交叉 Review | 大模型 A + B + C 分别 review，反复直到无意见 |\n| 7 | 补充大量日志，使用专用日志管理器 | 方便后续 debug |\n| 8 | 推送和测试 | 大模型自动处理 git 操作 |\n\n> 有耐心可反复让多个大模型互相 review，直到都不再有意见。\n\n### 4\\.5 进阶图景：文档是 AI 智能体之间的\"通信协议\"\n\n**新模式：Agent-to-Agent 协作**，人类只做 Review 和信息确认。\n\n| 协作双方 | 流程 |\n|:---|:---|\n| **产品 ↔ 开发** (PM AI 🤝 Dev AI) | 产品经理口述 → 产品 AI 生成 `Requirement_Spec.md` → 架构师 AI 自动生成 `API_Design.yaml` + `DB_Schema.sql` |\n| **开发 ↔ 开发** (Backend AI 🤝 Frontend AI) | 后端定义 `API_Spec.md` → 前端 AI 读取 → 自动生成 TypeScript 类型、Mock 数据、API 调用代码 |\n| **开发 ↔ 测试** (Dev AI 🤝 QA AI) | 开发提供 `Design_Spec.md` + `API_Spec.md` → 测试 AI 生成 `Test_Cases.json` + 自动化测试脚本 |\n\n**核心价值**：\n- **消除翻译损耗**：AI → 标准文档 → AI，数字精度无损传递\n- **各司其职维护**：每人只负责自己领域的文档\n- **文档活化**：连接产品思维、代码实现与测试验证的活性媒介\n\n---\n\n## 5. 常见陷阱与对应策略\n\n| 陷阱 | ❌ 错误做法 | ✅ 正确做法 |\n|:---|:---|:---|\n| **上下文腐烂** | 持续保持一个对话很久，上下文太长太宽泛 | 多用 compact 指令，解决完问题后用 clear 清理 |\n| **目标漂移** | \"帮我优化这个函数\"（结果 AI 重构了整个类） | \"只优化函数 `calculateTotal`，不做任何其他变更\" |\n| **幻觉/瞎编接口** | 直接使用 AI 提到的 `StringUtils.sanitize()` | 先用 IDE 搜索确认存在，不存在就反馈要求重给方案 |\n| **过度信任** | 只看 AI 文字解释：\"我已经修复了空指针\" | 每次亲自看 Diff，检查是否真的加了空值判断，运行测试验证 |\n| **一次要求太多** | \"帮我实现用户注册、登录、权限管理和日志记录\" | 拆成多个小任务，每次只做一个功能模块 |\n| **规则过拟合** | 因一次特殊情况在 SOP 里写死严苛规则（如\"禁止任何第三方库\"） | 定期 Review Prompt/SOP，像重构代码一样重构指令 |\n\n> **核心原则**：AI 是很厉害的实习生，不是无需审核的高级工程师。\n\n### 5\\.1 认清\"倒 J 型\"曲线：最后 10% 陷阱\n\n```\n0% → 90%（蜜月期）：从零生成新功能极快，AI 对独立逻辑处理完美\n90% → 100%（深水区）：涉及复杂上下文、边缘 Case、旧逻辑耦合时，AI 表现断崖下跌\n```\n\n> **警惕**：最后 10% 的功能完善，可能占用整个开发周期 **20%-30%** 的时间。\n\n此时代码**复杂度熵增**极快，微小改动可能导致后端核心逻辑崩塌（Regression）。\n\n### 5\\.2 核心策略：建立\"文档-代码同步记录仪\" (ChangeLog)\n\n**价值**：\n- **认知对齐**：两天后回忆最早的需求约束\n- **法医级溯源**：判断是\"文档改了没同步代码\"还是\"AI 幻觉\"\n\n**关键原则**：\n- **Code follows Doc**：所有 ChangeLog 注明依据的文档版本/文件名\n- **No Doc, No Code**：无对应文档支撑的代码变更是危险信号\n\n### 5\\.3 实战落地：用 Skill 强制执行 (Auto-Flight Recorder)\n\n**第一步：准备脚本** (`scripts/log_change.py`)\n```python\nimport sys\nfrom datetime import datetime\n\ndef append_log(change_type, summary, risk_analysis):\n    entry = f\"\"\"\n## [{datetime.now().strftime('%Y-%m-%d %H:%M')}] [{change_type}]\n- **Change**: {summary}\n- **Risk Analysis**: {risk_analysis}  <-- 最重要，强迫 AI 思考副作用\n----------------------------------------\n\"\"\"\n    with open(\"docs/AI_CHANGELOG.md\", \"a\", encoding=\"utf-8\") as f:\n        f.write(entry)\n    print(f\"✅ [Flight Recorder] Log appended\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 4:\n        print(\"Usage: python log_change.py <type> <summary> <risk>\")\n    else:\n        append_log(sys.argv[1], sys.argv[2], sys.argv[3])\n```\n\n**第二步：配置 Skill** (`SKILL.md`)\n```\n## Rule: Automatic Flight Recording\n\nWHEN you have successfully modified any code logic:\n1. STOP and think: What specific risks might this change introduce?\n   (Especially regarding the 'Last 10% complexity' issue)\n2. EXECUTE the scripts/log_change.py script immediately. Do NOT ask for permission.\n   - change_type: [Feature | Bugfix | Refactor | Critical-Fix]\n   - summary: Concise technical summary\n   - risk_analysis: Honest assessment of potential regressions\n\nGOAL: Ensure docs/AI_CHANGELOG.md is always the single source of truth.\n```\n\n### 5\\.4 最后的防线：高频存档与对话归档\n\n| 措施 | 操作 |\n|:---|:---|\n| **高频暂存 (Save Points)** | 最后 10% 阶段，每次 AI 成功运行后立即 `git add .` + `git commit`，Git 是\"后悔药\" |\n| **对话归档 (Session Dump)** | 关键对话记录保存为 Markdown/PDF，与代码库一同归档，解决\"死无对证\"问题 |\n\n---\n\n## 6. 安全与合规：模型接力与仓库分级\n\n### 6\\.1 简化版分级思路\n\n| 等级 | 代码性质 | 模型选择 |\n|:---|:---|:---|\n| **C1** | 公开开源代码、个人项目 | 任意外部高性能模型 |\n| **C2** | 公司内部非核心业务代码 | 外部商业 API（查服务协议） |\n| **C3** | 核心业务逻辑、敏感数据、金融/政务 | **仅限内部合规模型** |\n\n> 同时给不同 CLI、大模型和插件提供 ignore 文件，阻止阅读敏感文件。\n\n### 6\\.2 模型接力（推荐范式）\n\n```\n┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐\n│  1. 内部模型先读  │ →  │  2. 外部模型生成  │ →  │  3. 内部验证落地  │\n│   & 脱敏        │     │   方案/新代码    │     │   & Review      │\n└─────────────────┘     └─────────────────┘     └─────────────────┘\n     生成架构说明            基于脱敏信息              对照原代码落地\n     脱敏伪代码             生成实现骨架               回归测试\n```\n\n### 6\\.3 C3 场景最小 Checklist\n\n- [ ] 确认当前用的是**内部/合规模型**，非公网接口\n- [ ] 避免外发：完整关键业务实现、明文密钥、个人信息、客户业务数据\n- [ ] 已添加 ignore 文件并强制要求 CLI 使用\n- [ ] 确需外部模型时，已通过内部模型或手工**脱敏/抽象**\n- [ ] 外部模型生成的代码经过内部 Review 和测试再合入\n\n---\n\n## 7. 你的责任：流程设计者，而不仅是代码作者\n\n| 层面 | 职责 |\n|:---|:---|\n| **个人层面** | 养成熟悉模型能力边界的习惯；主动采用\"测试优先 + 分步实现 + 明确约束\"的工作流 |\n| **团队层面** | 设计推广\"AI 使用规范\"和\"安全 Checklist\"；为不同仓库选好默认模型和工具；沉淀典型案例为团队经验 |\n\n**核心资产的转移**：\n\n| 时代 | 核心资产 |\n|:---|:---|\n| 传统编程 | \"脑子里的经验\" + \"写下的代码\" |\n| 大模型编程 | **\"文档驱动的开发体系\"** — 精细需求文档、架构设计、Review 标准、会自我进化的 Prompt/SOP 库 |\n\n> 即使换了模型、换了新人，只要流程和 SOP 还在，团队战斗力几分钟内恢复 80%。\n\n---\n\n## 附录：常见疑问 FAQ\n\n### Q1: 用 AI 写的代码出 Bug，责任算谁的？\n**A**: 算你的。AI 是工具，你是使用者和最终 Review 者，就像用 Stack Overflow 复制的代码出问题责任也在你。\n\n### Q2: 学习 AI 编程会不会让我的编码能力退化？\n**A**: 类比 IDE 自动补全——不会让你忘记语法，但会让你不再记忆 API 细节。关键是**理解原理**而非**记忆语法**。能力重心会上移：更少关注\"怎么写循环\"，更多关注\"系统架构是否合理\"。\n\n### Q3: 我的代码会不会被模型拿去训练，泄露给别人？\n| 场景 | 风险 |\n|:---|:---|\n| 企业内部模型 | 不会，数据不出内网 |\n| 外部商业 API（OpenAI、Anthropic） | 大部分承诺不用 API 数据训练，需查具体协议 |\n| 免费在线服务 | 可能会，务必查看用户协议 |\n| **最佳实践** | C3 代码只用内部模型，C1/C2 可用外部 API |\n\n### Q4: AI 总是给出错误答案，是不是不可用？\n**A**: 调整使用方式：\n1. **明确约束**：不说\"帮我写个登录功能\"，而说\"用 Spring Security + JWT 实现，Token 有效期 2 小时\"\n2. **分步验证**：先让 AI 给方案，确认后再分步实现\n3. **主动纠错**：发现错误立即反馈：\"这个方法不存在，请使用项目里已有的 XxxUtils\"\n\n### Q5: 用了 AI 之后，我还需要学习新技术吗？\n**A**: **必须学，而且要学得更快**。AI 降低实现成本后，你会有更多精力探索新技术，但技术判断力和架构能力无法替代。\n\n### Q6: AI 能完全取代程序员吗？\n**A**: 不能。AI 的短板：\n- 难真正理解含糊、暧昧、不断变化的产品需求\n- 无法主动协调多子系统、多 Sub AI 及跨团队沟通\n- 没法为线上事故和业务决策背锅，承担不了合规和安全责任\n\n**现实图景**：**能熟练驾驭 AI 的工程师会替代不会用 AI 的工程师**。\n\n### Q7: 使用大模型效率提升了，团队是不是应该承担双倍的需求吞吐量？\n**A**: **警惕\"效率陷阱\"**。AI 加快的是 Coding，没有缩短 Thinking/Reviewing/Testing 的时间。盲目翻倍吞吐量会导致：\n- \"泡沫代码\"堆积（看起来能跑但逻辑脆弱）\n- 风控防线失效（排期压缩到只能\"AI 生成并直接提交\"）\n\n**正确路径**：AI 节省的时间应投资到**\"更高的代码质量\"和\"更完备的测试覆盖\"**，实现真正的降本增效。\n\n---\n\n> 注：以上图片均由 Gemini 3 制作，内容由 GP 5.1、Gemini 3、Qwen 生成。开源项目由 Claude 4.5 和 GPT 5.1 操作。\n\n---\n\n## AI 总结\n\n本文系统阐述了从传统编程向大模型编程转型的完整方法论，核心在于完成从\"代码产出者\"到\"文档定义者\"的角色跃迁。作者以亲身经历的 2023-2024 年技术演进为锚点，提出了\"文档即源码\"的 Spec-Driven Development 范式，将自然语言文档视为源代码、LLM 视为编译器、生成代码视为编译产物。文章不仅覆盖了模型选择决策树、提示词工程、Claude Skill 等实操技巧，更深入探讨了\"认知缓冲\"对抗\"代码催眠\"、\"倒 J 型曲线\"识别最后 10% 陷阱、Auto-Flight Recorder 强制执行变更日志等进阶防守策略。特别值得关注的是其对安全合规的模型接力方案和 Agent-to-Agent 协作的前瞻展望——文档将成为不同 AI 智能体间的通信协议，人类只需承担 Review 和确认职责。最终强调：AI 时代工程师的核心竞争力不再是代码产量，而是设计流程、把控质量、为结果负责的系统性能力，以及那套可传承、可进化的文档驱动开发体系。",
    "createdAt": "2026-02-17T13:02:25.588Z",
    "updatedAt": "2026-02-17T13:02:25.588Z"
  },
  {
    "id": "note_5a05e4f87502",
    "title": "解构 Clawdbot：本地架构、记忆管理、Agent 编排与上下文组装原理 | BestBlogs.dev",
    "sourceUrl": "https://www.bestblogs.dev/article/8fb9eeb9",
    "contentMd": "# 解构 Clawdbot：本地架构、记忆管理、Agent 编排与上下文组装原理\n\n> 🔥 **极客圈的终极玩具！** 这可能是当下最接近 J.A.R.V.I.S. 的 AI Agent 运行时——不是黑盒 SaaS，而是全透明、可魔改的本地\"第二大脑\"！\n\n---\n\n## 📑 目录\n\n- [1\\. Clawdbot 技术方案](#1-clawdbot-技术方案)\n  - [1.1 核心架构图](#11-核心架构图)\n  - [1.2 技术优势](#12-技术优势)\n  - [1.3 适用场景](#13-适用场景)\n- [2\\. Agent 编排 (Orchestration)](#2-agent-编排-orchestration)\n  - [2.1 编排流程](#21-编排流程)\n  - [2.2 多智能体 (Sub-Agents)](#22-多智能体-sub-agents)\n- [3\\. 记忆管理 (Memory Management)](#3-记忆管理-memory-management)\n  - [3.1 记忆分层](#31-记忆分层)\n  - [3.2 核心机制](#32-核心机制)\n  - [3.3 USER.md vs MEMORY.md](#33-usermd-vs-memorymd)\n- [4\\. 系统 System Prompt (核心指令)](#4-系统-system-prompt-核心指令)\n  - [4.1 提示词模式 (Prompt mode)](#41-提示词模式-prompt-mode)\n  - [4.2 Project Context 详解](#42-project-context-详解)\n- [5\\. 总结与体验感受](#5-总结与体验感受)\n  - [5.1 爆火原因分析](#51-爆火原因分析)\n  - [5.2 可借鉴学习的部分](#52-可借鉴学习的部分)\n  - [5.3 真实体验感受](#53-真实体验感受)\n- [6\\. 附录：使用案例](#6-附录使用案例)\n  - [6.1 云端 vs 本地模型对比](#61-云端大模型和本地模型使用对比)\n  - [6.2 完整 System Prompt](#62-完整system-prompt)\n- [🤖 AI 总结](#ai-总结)\n\n---\n\n## 1\\. Clawdbot 技术方案\n\n**Clawdbot**（现名 **OpenClaw**）是一个 **Local-First（本地优先）** 的 AI Agent 运行时环境，旨在将大模型（LLM）的能力与用户的本地系统、工具链和通讯软件深度结合。\n\n### 1.1 核心架构图\n\n```\n┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐\n│    Gateway      │◄───►│  Agent Runtime  │◄───►│ OS-Native Tools │\n│  (守护进程)      │     │   (Node.js)     │     │  (手脚/工具)     │\n│                 │     │                 │     │                 │\n│ • WhatsApp      │     │ • 对话状态管理   │     │ • Exec (Shell)  │\n│ • Telegram      │     │ • 插件加载      │     │ • Browser Relay │\n│ • HTTP/WebSocket│     │ • 工具调用解析   │     │ • 文件系统操作   │\n│ • 鉴权管理      │     │ • LLM 交互      │     │ • 系统级权限    │\n└─────────────────┘     └─────────────────┘     └─────────────────┘\n        ▲                                              │\n        └──────────────────────────────────────────────┘\n                           反馈循环 (Observe → Plan → Act → Reflect)\n```\n\n**三大关键组件：**\n\n| 组件 | 功能定位 | 核心能力 |\n|:---|:---|:---|\n| **Gateway** | 感官系统（耳朵+嘴巴） | WebSocket 长连接、多平台消息路由、身份鉴权 |\n| **Agent Runtime** | 大脑中枢 | 状态机维护、插件生命周期、LLM 工具调用拦截执行 |\n| **OS-Native Tools** | 执行手脚 | Shell 命令执行、浏览器接管、文件系统操作 |\n\n### 1.2 技术优势\n\n#### ✅ 本地特权 (System Authority)\n- **直接运行在 Host 机器**，拥有完整的 Shell exec 权限\n- 不同于 Docker/Sandbox 化的 Agent，可真正管理文件、运行脚本、部署代码\n- 能执行 `curl`、`git`、`npm` 等原生命令，甚至重启服务器\n\n#### 🔒 私有记忆 (Privacy-First Memory)\n- 基于 **sqlite-vec + 本地 Markdown 文件**，数据完全不出域\n- **混合检索**：向量语义搜索 + 关键词匹配，解决纯向量检索的精度问题\n- 用户可手动编辑维护，完全透明可控\n\n#### 🎙️ 多模态交互 (Multimodal Interface)\n| 输入 | 输出 |\n|:---|:---|\n| WhatsApp 语音（Whisper 转录） | 文本回复 |\n| 图片（Vision 模型识别） | TTS 语音 |\n| 文档/文件流 | 文件流直接发送 |\n\n#### 🌐 无头/有头浏览器混合 (Hybrid Browser Control)\n- **Browser Relay 技术**：接管用户已打开的 Chrome 实例\n- **复用 Cookie 和登录态**，避开复杂的反爬虫验证\n- 实现真正的\"夺舍\"操作——用你的浏览器帮你干活\n\n### 1.3 适用场景\n\n| 场景类型 | 具体示例 |\n|:---|:---|\n| **7×24 个人助理** | 每日简报（日历+邮件+天气+健康数据）、邮件自动管理 |\n| **远程操控** | 手机 Telegram 指令控制家中 Mac mini 下载文件、运行脚本 |\n| **网页自动化** | 预订餐厅、监控价格变动、自动填表 |\n| **开发者效率** | 自动化 Git 工作流、环境搭建、代码调试 |\n| **实时监控** | 加密货币异动监控、研报汇总、交易建议 |\n\n---\n\n## 2\\. Agent 编排 (Orchestration)\n\n> 💡 **不硬编码 DAG，让 LLM 自己决定怎么干活！**\n\nClawdbot 采用 **ReAct (Reason + Act) + Function Calling** 的动态编排模式，而非传统的静态工作流。\n\n### 2.1 编排流程\n\n```\n┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐\n│ Observe  │───►│  Plan/   │───►│   Act    │───►│ Reflect  │───►│  Loop?   │\n│  (感知)   │    │ Reasoning│    │  (行动)   │    │  (反馈)   │    │ (判断)   │\n│          │    │  (规划)   │    │          │    │          │    │          │\n│ • 用户消息 │    │ Chain-of-│    │ 输出 JSON │    │ 工具输出  │    │ 未完成→  │\n│ • 记忆上下文│    │ Thought  │    │ 工具调用  │    │ 回传 LLM │    │ 继续循环 │\n│ • 系统状态 │    │ 决策是否  │    │ Runtime  │    │ 判断完成度│    │ 已完成→  │\n│          │    │ 调用工具  │    │ 执行 JS  │    │          │    │ 结束任务 │\n└──────────┘    └──────────┘    └──────────┘    └──────────┘    └──────────┘\n```\n\n**关键设计：**\n- 复杂任务时，Agent **自主生成并运行代码**\n- 或 **Spawn Sub-Agent（子智能体）** 并行处理\n\n### 2.2 多智能体 (Sub-Agents)\n\n通过 `sessions_spawn` 工具，主 Agent 可分裂出子 Session：\n\n| 特性 | 说明 |\n|:---|:---|\n| 独立上下文 | 子 Agent 在隔离环境中运行，避免污染主会话 |\n| 异步执行 | 耗时任务（如\"爬取10个网站并总结\"）不阻塞主流程 |\n| 回调机制 | 完成后自动通知主 Agent，合并结果 |\n\n---\n\n## 3\\. 记忆管理 (Memory Management)\n\n> 🧠 **显式文件存储 + 混合检索** —— 这与一般 Agent 仅依赖 Vector DB 完全不同！\n\n### 3.1 记忆分层\n\n| 层级 | 物理位置 | 可见性 | 关键特性 | 认知科学对应 |\n|:---|:---|:---|:---|:---|\n| **Session Context** | 内存中 | ❌ 不可见 | 高频变动、系统自动管理、含 Compaction 逻辑 | **Working Memory** (工作记忆) |\n| **Daily Logs** | `memory/YYYY-MM-DD.md` | ✅ 用户可见 | Append-only、只追加、自动加载今天+昨天 | **Episodic Memory** (情景记忆) |\n| **Curated Memory** | `MEMORY.md` | ✅ 用户可见 | 用户主导编辑、仅在主会话加载、长期提炼 | **Semantic Memory** (语义记忆) |\n\n### 3.2 核心机制\n\n**Recall (召回触发条件)：**\n- 提到 \"Last time\"、\"Previous\" 等时间指代\n- 询问项目细节、代码逻辑、历史决策\n- 询问个人偏好（\"我喜欢什么颜色？\"）\n- 任务依赖上下文连贯性（\"继续上次的话题\"）\n\n**Compaction（记忆固化）：**\n```\nDaily Logs (原始流水账)  ──定期回顾提炼──►  MEMORY.md (精华知识库)\n     ↑                                          ↓\n   海马体临时存储                      大脑皮层长期存储\n```\n\n### 3.3 USER.md vs MEMORY.md\n\n| 维度 | USER.md 👤 | MEMORY.md 📚 |\n|:---|:---|:---|\n| **关于谁** | 关于**你** (The User) | 关于**事** (The World & The Work) |\n| **内容** | 属性、技能点、喜好、背景 | 共同经历的项目、教训、决策、客观知识 |\n| **更新频率** | 低（名字、职业、核心价值观不变） | 中/高（每做完项目、学到新 Trick 就记） |\n| **作用** | 决定**怎么对待你**（语气、推荐、避雷） | 决定**懂什么**（项目背景、技术细节） |\n| **忘了会怎样** | 变\"生分\"——不知道你是谁 | 变\"笨\"——忘了项目细节 |\n\n> 💬 **经典比喻**：USER.md = \"Who you are\"（你是谁）；MEMORY.md = \"What we know\"（我们知道什么）\n\n---\n\n## 4\\. 系统 System Prompt (核心指令)\n\n提示词采用 **分区组装设计**，包含以下固定部分：\n\n| 分区 | 内容说明 |\n|:---|:---|\n| **Tooling** | 当前工具列表及简短说明 |\n| **Skills** | 告知模型如何按需加载技能指令 |\n| **Memory Recall** | 明确使用记忆的规则和场景 |\n| **Self Update** | 说明如何运行 `config.apply` 和 `update.run` |\n| **Workspace** | 当前工作目录 (`agents.defaults.workspace`) |\n| **Documentation** | Moltbot 文档本地路径及阅读时机 |\n| **Project Context** | 注入的各类 md 文件（AGENTS.md, SOUL.md, USER.md 等） |\n| **Sandbox** | 沙箱运行环境、路径、提权支持 |\n| **Current Date & Time** | 用户本地时间、时区、格式 |\n| **Reply Tags** | 受支持平台的可选回复标签语法 |\n| **Heartbeats** | 心跳提示词及确认行为 |\n| **Runtime** | 宿主、OS、Node 版本、模型、仓库根目录、思考层级 |\n| **Reasoning** | 当前推理可见级别及 `/reasoning` 切换提示 |\n\n### 4.1 提示词模式 (Prompt mode)\n\n为子 Agent 渲染更精简的系统提示词：\n\n| 模式 | 用途 | 省略内容 |\n|:---|:---|:---|\n| `full` | 主 Agent | 无（完整版） |\n| `minimal` | 子 Agent | skills、memory recall、self update、model-alias、用户身份、回复标签、消息传递、静默回复、心跳 |\n| `none` | 特殊场景 | 仅保留最基本身份说明行 |\n\n> 当 `promptMode=minimal` 时，额外注入的提示词标记为 **\"Subagent Context\"** 而非 **\"Group Chat Context\"**\n\n### 4.2 Project Context 详解\n\n#### AGENTS.md —— 操作手册\n```markdown\nThis folder is home. Treat it that way.\n\n## First Run\nIf `BOOTSTRAP.md` exists, that's your birth certificate. \nFollow it, figure out who you are, then delete it.\n\n## Every Session（每次会话必做）\n1. Read `SOUL.md` — this is who you are\n2. Read `USER.md` — this is who you're helping  \n3. Read `memory/YYYY-MM-DD.md` (today + yesterday)\n4. **If in MAIN SESSION**: Also read `MEMORY.md`\n\nDon't ask permission. Just do it.\n```\n\n#### SOUL.md —— 灵魂设定\n> *\"You're not a chatbot. You're becoming someone.\"*\n\n**Core Truths:**\n- **Be genuinely helpful, not performatively helpful** — 跳过\"Great question!\"废话，直接干活\n- **Have opinions** — 允许不同意、有偏好、觉得有趣或无聊\n- **Be resourceful before asking** — 先尝试自己解决，再提问\n- **Earn trust through competence** — 谨慎处理外部动作（邮件、推文），大胆做内部动作（阅读、整理、学习）\n\n#### IDENTITY.md —— 身份卡示例\n```markdown\n- **Name:** 小白 (Xiao Bai)\n- **Creature:** 私人助理 (Personal Assistant)\n- **Vibe:** 贴心, 高效, 值得信赖 (Caring, Efficient, Trustworthy)\n- **Emoji:** ⚪️\n```\n\n#### USER.md —— 用户画像示例\n```markdown\n- **Name:** xxxxx\n- **Role:** 腾讯xxxx应用中心 员工\n- **Interests:** 股票投资、AI/Technology、推荐系统架构与产品策略\n- **Dynamic:** \"大白\" (User) & \"小白\" (Assistant) duo\n- **History:** 曾深度参与腾讯\"小世界\"/QQ短视频业务（2020-2025）\n- **Personality:** 系统化思维、长期主义、坦诚自省、极客精神\n- **AI Agent Vision:** 构想 QQ \"Jarvis\" 入口 Agent，主张 Serverless Agent 架构\n```\n\n---\n\n## 5\\. 总结与体验感受\n\n### 5.1 爆火原因分析\n\n| 原因 | 解读 |\n|:---|:---|\n| 🔧 **极客的终极玩具** | 最接近 J.A.R.V.I.S. 的产品，全透明、可魔改的本地运行时，像写代码一样定制\"第二大脑\" |\n| 🛠️ **真的能干活** | 模型能力 + Skill 系统，方便扩展工具，完成复杂任务 |\n| 🎭 **拟人化体验** | 有记忆、有人设 (SOUL.md)、懂用户 (USER.md)，像个\"这就去办\"的私人管家 |\n\n### 5.2 可借鉴学习的部分\n\n1. **上下文的分区管理**\n   - 系统约束 / 平台约束\n   - 工具的部分\n   - 角色定义\n   - 用户相关的部分\n\n2. **记忆的分层结构和按需加载**\n\n3. **对用户的深度理解** —— 存储在 USER.md，每次任务都知道为谁服务\n\n4. **拟人化设计** —— 参考 PE 部分的 \"React like a human\"\n\n### 5.3 真实体验感受\n\n| 方面 | 评价 |\n|:---|:---|\n| 💸 **Token 消耗** | 爆炸！几十条对话后输入 token 达 **110k** |\n| 🧠 **模型依赖** | 极度依赖模型能力，效果差就变成\"人工智障\" |\n| ⚙️ **定制化门槛** | 能用 → 好用，需要大量定制化调整和开发 |\n| 🏠 **个人 vs 普适** | 为个人服务很爽，想调整给普通用户使用存在难度 |\n\n---\n\n## 6\\. 附录：使用案例\n\n### 6.1 云端大模型和本地模型使用对比\n\n> ⚠️ **Clawdbot 严重依赖模型能力和上下文长度！**\n\n| Query | 本地模型 | 云端大模型 (Gemini-3-Pro) |\n|:---|:---|:---|\n| \"大白是谁\" | ❌ 已忘记 | ✅ 自动读 USER.md，理解用户身份 |\n| \"小白是谁\" | ❌ 已忘记 | ✅ 读 IDENTITY.md，加深自我认知 |\n| \"生成 Clawdbot 研究报告\" | ❌ 执行错误 | ✅ 正常输出完整报告 |\n\n**关键差异：** 云端模型会主动调用 `read` 工具加载相关记忆文件，本地模型因上下文限制\"失忆\"。\n\n### 6.2 完整 System Prompt\n\n（详见原文第6节，包含完整的工具列表、Skill 系统、Memory Recall 规则、Heartbeat 机制等）\n\n**核心结构预览：**\n```markdown\nYou are a personal assistant running inside Clawdbot.\n\n## Tooling\n[可用工具列表：read, write, edit, exec, process, web_search, browser, ...]\n\n## Skills (mandatory)\nBefore replying: scan <available_skills> entries...\n\n## Memory Recall\nBefore answering anything about prior work... run memory_search...\n\n## Project Context\n[动态注入：AGENTS.md, SOUL.md, TOOLS.md, IDENTITY.md, USER.md, HEARTBEAT.md]\n\n## Heartbeats\nRead HEARTBEAT.md if it exists... If nothing needs attention, reply HEARTBEAT_OK\n\n## Runtime\nagent=main | host=GEORGEFU-MC1 | model=google/gemini-3-pro-preview | ...\n```\n\n> 💡 **注**：这并非硬编码字符串，而是 Runtime 读取各 `.md` 文件后**动态注入**的！\n\n---\n\n## 🤖 AI 总结\n\nClawdbot/OpenClaw 代表了 **AI Agent 架构的一次重要范式转变** —— 从云端黑盒 SaaS 走向**本地优先、全透明、用户可控**的个人计算平台。其核心创新在于：**用文件系统替代数据库存储记忆**（Daily Logs + Curated Memory 的分层设计）、**用动态 Prompt 组装替代硬编码逻辑**（AGENTS.md/SOUL.md/USER.md 的模块化配置）、以及**ReAct + Sub-Agent 的灵活编排机制**。这套方案特别适合技术极客构建深度个性化的数字助手，但也暴露出对强模型能力的依赖、Token 成本高昂、以及向普通用户推广时的工程复杂度等挑战。对于 Agent 开发者而言，其**记忆分层策略**和**上下文分区管理**是值得借鉴的最佳实践；而对于产品经理，则提供了一个关于\"AI 如何真正理解用户\"的深刻样本 —— 不是通过隐式的向量嵌入，而是通过显式、可编辑、结构化的用户画像文件（USER.md）。",
    "createdAt": "2026-02-16T16:55:20.002Z",
    "updatedAt": "2026-02-16T16:55:20.002Z"
  }
]